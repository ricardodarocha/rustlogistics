# Boas prÃ¡ticas

Este documento orienta os programadores do time a aderir ao guia de boas prÃ¡ticas, baseado nos conceitos mais modernos de boas prÃ¡ticas de desenvolvimento da comunidade de software.
 - Ergonomia: SÃ£o as decisÃµes de fluxo de trabalho, equipamentos, ambiente e ferramentas do dia a dia que propiciem boa qualidade de vida, clareza, acessibilidade e bem estar dos programadores e testadores.
 - Clean Code: CÃ³digo Limpo Ã© uma premissa de organizaÃ§Ã£o de cÃ³digo, escrita de cÃ³digo claro, de fÃ¡cil leitura, fÃ¡cil de dar manutenÃ§Ã£o e com baixa carga cognitiva (baixo tempo de aprendizado).
 - SOLID: SOLID sÃ£o princÃ­pios de ProgramaÃ§Ã£o Orientada a Objetos POO mas que sÃ£o aplicÃ¡veis em certa medida em todos os tipos de sistema, consitem em criar cÃ³digo preciso, unitÃ¡rio, coezo e com nÃ­veis certos de abstraÃ§Ã£o.
 - KISS: Sigla para Keep It Stupdly Simple, uma premissa que norteia a criaÃ§Ã£o de cÃ³digo simples, que exija o menor esforÃ§o possÃ­vel para a soluÃ§Ã£o do problema do domÃ­nio especÃ­fico
 - DRY: Sigla para _Dont Repeat Yourself_ um lema do reaproveitamento de cÃ³digo e organizaÃ§Ã£o de modo a compartilhar cÃ³digo entre diferentes projetos ou de projetar fluxos de trabalho que minimizem a aÃ§Ã£o de copiar e colar.

## Regras gerais

Para ajudar na compreensÃ£o e facilitar a comunicaÃ§Ã£o do time, devem-se adotar alguns padrÃµes

Nomes de variÃ¡vel em portuguÃªs, sempre que possÃ­vel, exceto convenÃ§Ãµes (*main, peek, push, tail etc*)
Componentes simples, pequenos, fÃ¡ceis de entender
NÃ£o usar funÃ§Ãµes complicadas
NÃ£o usar lÃ³gica complicada
NÃ£o usar cÃ³digo duplicado
Evitar ReferÃªncia Circular

Nomenclatura de variÃ¡veis
```C
nomeVariavel  //pascalCase
NomeStruct    //CamelCase
nome_funcao() //snake_case()
```

## OrganizaÃ§Ã£o das pastas

Adotamos uma estrutura modular e escalÃ¡vel, ideal para um time de 3 pessoas com papÃ©is claros (Tecnologia, DomÃ­nio e AplicaÃ§Ã£o).

ğŸ¯ Objetivo

Organizar o projeto em camadas:

```C
lib/ â†’ infraestrutura genÃ©rica (listas, Ã¡rvores, utilitÃ¡rios)

models/ â†’ definiÃ§Ãµes de structs de domÃ­nio (Produto, Cliente, etc.)

src/ â†’ aplicaÃ§Ã£o principal (lÃ³gica de negÃ³cio, main)

include/ â†’ headers (.h) de toda a aplicaÃ§Ã£o, para controle claro de dependÃªncias

ğŸ“ Estrutura de pastas
meu_programa/
â”‚
â”œâ”€â”€ include/                    # CabeÃ§alhos pÃºblicos
â”‚   â”œâ”€â”€ listagenerica.h
â”‚   â”œâ”€â”€ arvore.h
â”‚   â”œâ”€â”€ produto.h
â”‚   â”œâ”€â”€ cliente.h
â”‚   â””â”€â”€ app.h
â”‚
â”œâ”€â”€ lib/                        # ImplementaÃ§Ãµes genÃ©ricas e reutilizÃ¡veis
â”‚   â”œâ”€â”€ listagenerica.c
â”‚   â””â”€â”€ arvore.c
â”‚
â”œâ”€â”€ models/                     # Modelos de domÃ­nio
â”‚   â”œâ”€â”€ produto.c
â”‚   â””â”€â”€ cliente.c
â”‚
â”œâ”€â”€ src/                        # CÃ³digo da aplicaÃ§Ã£o
â”‚   â”œâ”€â”€ main.c
â”‚   â”œâ”€â”€ cadastro.c
â”‚   â”œâ”€â”€ login.c
â”‚   â””â”€â”€ entrega.c
â”‚
â”œâ”€â”€ Makefile                    # AutomaÃ§Ã£o de build
â””â”€â”€ README.md
```

## ğŸ‘¨â€ğŸ’» CriaÃ§Ã£o de novos arquivos

ğŸ“¦ Exemplo: models/produto.c
```C
#include <stdio.h>
#include <stdlib.h>
#include "../include/produto.h"

Produto *criar_produto(int id, const char *nome, float valor) {
    Produto *p = malloc(sizeof(Produto));
    p->id = id;
    snprintf(p->nome, sizeof(p->nome), "%s", nome);
    p->valor = valor;
    return p;
}

void exibir_produto(Produto *p) {
    printf("ID: %d | Nome: %s | Valor: %.2f\n", p->id, p->nome, p->valor);
}
```

ğŸ§© Exemplo: include/produto.h
```
#ifndef PRODUTO_H
#define PRODUTO_H

typedef struct {
    int id;
    char nome[100];
    float valor;
} Produto;

Produto *criar_produto(int id, const char *nome, float valor);
void exibir_produto(Produto *p);

#endif
```
Para criar um arquivo de cabeÃ§alho no Code Blocks clique no menu File-new-file e na janela que aparecer escolha a opÃ§Ã£o header (cabeÃ§alho).

Como um arquivo de cabeÃ§alho pode ser incluÃ­do em diversos arquivos diferentes, precisamos ter o cuidado de nÃ£o carregÃ¡-lo mais de uma vez, isso irÃ¡ duplicar nossas estruturas, funÃ§Ãµes e procedimentos podendo ocasionar em erros durante a execuÃ§Ã£o do programa. Para evitar isso, podemos verificar se o arquivo jÃ¡ foi carregado por meio de uma estrutura if.

O `ifndef significa if not defined`, ou seja, se nÃ£o existir uma definiÃ§Ã£o chamada `NOME_MODULO`, entÃ£o essa definiÃ§Ã£o serÃ¡ criada (na linha seguinte), assim como as estruturas serÃ£o criadas e as assinaturas das nossas funÃ§Ãµes e procedimentos.

Caso a definiÃ§Ã£o NOME_MODULO jÃ¡ exista, o fluxo de execuÃ§Ã£o irÃ¡ para endif e nada serÃ¡ feito.

O nome NOME_MODULO nÃ£o precisa ser exatamente assim. O importante Ã© que seja exatamente o mesmo nome na primeira e segunda linhas do arquivo.h, deve ser um nome diferente pra cada arquivo.

// arquivo pilha.h
```
#ifndef PILHA_H_INCLUDED
#define PILHA_H_INCLUDED
typedef struct no{
    int valor;
    struct no *proximo;
}No;
No* empilhar(No *pilha, int num);
No* desempilhar(No **pilha);
void imprimir(No *pilha);
#endif 
```

Agora que jÃ¡ temos nosso arquivo de cabeÃ§alhos, perceba que ele possui apenas as estruturas que iremos utilizar e as assinaturas das funÃ§Ãµes e procedimentos, das operaÃ§Ãµes da nossa TAD. Precisamos criar propriamente estas funÃ§Ãµes e procedimentos. Para isso vamos criar um novo arquivo chamado pilha.c.

Ã‰ dentro deste arquivo pilha.c que teremos nossas funÃ§Ãµes e procedimentos para operar sobre nosso conjunto de dados, a pilha. Este arquivo precisa de dois includes, o arquivo de cabeÃ§alho stdio.h, onde estÃ¡ definido a constante NULL e o arquivo de cabeÃ§alho pilha.h que acabamos de criar.

Observe que a inclusÃ£o do nosso arquivo fica entre um par de aspas duplas. Isso diz para o computador procurar este arquivo dentro do diretÃ³rio do nosso projeto. Ao utilizar os sinais de maior e menor o compilador irÃ¡ procurar este arquivo diretamente na pasta padrÃ£o do compilador, como stdio.h. Como o arquivo pilha.h estÃ¡ na pasta do projeto e nÃ£o na pasta padrÃ£o do compilador, teremos um erro se tentarmos usar os sinais de maior menor no lugar das aspas duplas.

// arquivo pilha.c
```C
#include <stdio.h>
#include "pilha.h"
No* empilhar(No *pilha, int num){
    No *novo = malloc(sizeof(No));
    if(novo){
        novo->valor = num;
        novo->proximo = pilha;
        return novo;
    }
    else
        printf("Erro ao alocar memoria!\n");
    return NULL;
}
No* desempilhar(No **pilha){
    No *remover = NULL;
    if(*pilha){
        remover = *pilha;
        *pilha = remover->proximo;
    }
    else
        printf("Pilha vazia!\n");
    return remover;
}
void imprimir(No *pilha){
    printf("\n\tPILHA\n");
    while(pilha){
        printf("\t%d\n", pilha->valor);
        pilha = pilha->proximo;
    }
    printf("\n");
}
```

Agora vamos criar nosso arquivo main.c. Neste arquivo, alÃ©m dos includes que jÃ¡ estamos acostumados, tambÃ©m precisamos incluir nosso arquivo de cabeÃ§alho pilha.h.

Perceba que a funÃ§Ã£o fatorial nÃ£o estÃ¡ definida no arquivo pilha.h nem no arquivo pilha.c, isso porque esta funÃ§Ã£o nÃ£o Ã© uma operaÃ§Ã£o que age sobre nosso conjunto de dados, como empilhar, desempilhar ou imprimir. Isso faz parte da organizaÃ§Ã£o do cÃ³digo. Imagine que alÃ©m da estrutura pilha, tambÃ©m tivÃ©ssemos uma fila e uma lista encadeada (estruturas que veremos aqui no curso), poderÃ­amos ter mais quatro arquivos:
â€“ fila.h
â€“ fila.c
â€“ lista.h
â€“ lista.c

Assim, cada arquivo contÃ©m o cÃ³digo de um TAD, deixando o cÃ³digo mais organizado e tornando a manutenÃ§Ã£o mais rÃ¡pida e precisa.
```C
/*
                 arquivo main.c
                 CÃ³digo escrito por Wagner Gaspar
                 Julho de 2021
*/
#include <stdio.h>
#include <stdlib.h>
#include "pilha.h"
int fatorial(int num){
    No *remover, *pilha = NULL;
    while(num > 1){
        pilha = empilhar(pilha, num);
        num--;
    }
    imprimir(pilha); // 2 3
    while(pilha){
        remover = desempilhar(&pilha);
        num = num * remover->valor;
        free(remover);
    }
    return num;
}
int main(){
    int valor;
    printf("Digite um valor maior que zero para o fatorial: ");
    scanf("%d", &valor);
    printf("\tFatorial de %d: %d\n", valor, fatorial(valor));
}
```

ğŸš€ Exemplo: src/main.c
```C
#include <stdio.h>
#include "../include/listagenerica.h"
#include "../include/produto.h"

int main() {
    printf("=== Sistema de Cadastro ===\n");

    ListaGenerica *listaProdutos = criar_lista();

    Produto *p1 = criar_produto(1, "Arroz", 10.50);
    Produto *p2 = criar_produto(2, "FeijÃ£o", 8.90);

    inserir(listaProdutos, p1);
    inserir(listaProdutos, p2);

    exibir_produto(p1);
    exibir_produto(p2);

    return 0;
}
```

## ğŸ§° Makefile simples

```C
CC = gcc
CFLAGS = -Iinclude -Wall
OBJ = lib/listagenerica.o models/produto.o src/main.o

meu_programa: $(OBJ)
	$(CC) -o $@ $(OBJ)

%.o: %.c
	$(CC) $(CFLAGS) -c $< -o $@

clean:
	rm -f $(OBJ) meu_programa
```

## ğŸ’¡ BenefÃ­cios dessa organizaÃ§Ã£o

âœ… Cada Ã¡rea tem autonomia sem interferir nas outras.
âœ… Facilita testes isolados (por ex. make test-lib para testar lib/).
âœ… Padroniza inclusÃ£o de headers (#include "../include/...").
âœ… Evita dependÃªncias circulares.
âœ… FÃ¡cil expansÃ£o â€” basta adicionar novas structs em models/.

## ConfiguraÃ§Ã£o do terminal

o terminal fica com caracteres estranhos como habilitar caracteres especiais no codigo para imprimri direto no terminal

esse problema Ã© muito comum em programas C que imprimem arte ASCII ou box drawings (como â•”â•â•—, â•‘ â•‘, â•šâ•â•).
Quando o terminal mostra caracteres estranhos (ï¿½, Ã§, etc.), normalmente Ã© por causa de incompatibilidade de codificaÃ§Ã£o.
Aqui vai um guia completo pra resolver em Windows, no seu cÃ³digo em C, no terminal e no VSCode/Dev-C++ ğŸ‘‡

ğŸ§© 1ï¸âƒ£ Entendendo o problema

Esses caracteres (â•”, â•‘, â•š, â”€, etc.) fazem parte da tabela de caracteres estendida (OEM 437 ou 850).
Mas o Windows Terminal, CMD ou VSCode geralmente usa UTF-8 (codepage 65001).

VocÃª precisa configurar o terminal e o cÃ³digo fonte para a mesma codificaÃ§Ã£o.

ğŸ§© 2ï¸âƒ£ SoluÃ§Ãµes prÃ¡ticas
âœ… OpÃ§Ã£o 1 â€“ Usar UTF-8 (recomendada)

No inÃ­cio do seu main(), adicione:

```C
#include <windows.h>
#include <stdio.h>

int main(void) {
    // Define UTF-8 no terminal
    SetConsoleOutputCP(CP_UTF8);
    SetConsoleCP(CP_UTF8);

    printf("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n");
    printf("â•‘   BEM-VINDO AO SISTEMA BOX LOGISTICS     â•‘\n");
    printf("â•‘              VersÃ£o 0.1 (2025)           â•‘\n");
    printf("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");

    return 0;
}
```


ğŸ’¡ Certifique-se de que o arquivo .c estÃ¡ salvo em UTF-8 sem BOM (no VSCode: â€œSalvar com codificaÃ§Ã£o â†’ UTF-8â€).
ğŸ’¡ No terminal, digite antes de rodar:
chcp 65001

âœ… OpÃ§Ã£o 2 â€“ Usar o conjunto `OEM 437` (modo clÃ¡ssico do DOS)

Se quiser rodar igual aos antigos sistemas DOS:

```C
#include <windows.h>
#include <stdio.h>

int main(void) {
    SetConsoleOutputCP(437); // CÃ³digo OEM dos box-drawings antigos

    printf("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n");
    printf("â•‘   BEM-VINDO AO SISTEMA BOX LOGISTICS     â•‘\n");
    printf("â•‘              VersÃ£o 0.1 (2025)           â•‘\n");
    printf("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");

    return 0;
}
```

Digite no terminal: `chcp 437 `

ğŸ¨ Isso garante compatibilidade com os caracteres da tabela ASCII estendida original (usada em Turbo C e DOS).

ğŸ§© 3ï¸âƒ£ Dica bÃ´nus â€” Teste automÃ¡tico de charset

VocÃª pode detectar se o terminal suporta UTF-8 e ajustar:

UINT codepage = GetConsoleOutputCP();
if (codepage != CP_UTF8) SetConsoleOutputCP(CP_UTF8);

ğŸ§© 4ï¸âƒ£ VerificaÃ§Ã£o no VSCode

VÃ¡ em Arquivo â†’ Salvar com codificaÃ§Ã£o â†’ UTF-8 sem BOM

VÃ¡ em ConfiguraÃ§Ãµes â†’ Terminal â†’ Integrated: Set locale to UTF-8


## Referencias bibliograficas

1. https://wagnergaspar.com/como-criar-arquivos-de-cabecalho-h-na-linguagem-c/
2. https://medium.com/@fabiano.salles/generic-linked-list-in-c-157dc49767bc
